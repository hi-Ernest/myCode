
-- The SQL Foundation


/*
  creat table
  drop
  alter table XX to XXX
  alter table 表名 add column 列名
                  drop

  插入：
      start transaction; //(or begin (SQL Server)) 开启事务
      insert into Product values ('1001','T恤',200,556,'2006-02-23');
      commit; //确认提交

 */
select product_type, count(*), avg(sale_price)
from product
/*
  对表数据指定筛选条件
  各种运算符： 加减乘除、and、or、is null、is not null
 */

where product_type = '衣服' and avg(sale_price)
/*
  对表进行分组: 分组键
  不能使用别名
  排序是随机的
  执行顺序： from -> where -> group by -> select
*/
group by product_type;
-- 为聚合结果指定条件 --> 通俗就是指定条件 -> 筛选组
-- 条件: 常数、聚合函数、group by子句中指定的列名(聚合键)
having avg(sale_price)>=2500

-- 升序：默认(ASC)
-- 讲序：DESC
-- 可以指定多个排序键    特别：null可能开头或末尾
-- 可以使用别名：SQL执行---> 先执行 select 再会执行 order by
order by sale_price, product_id


-- 多行插入
insert into productIns values ('002', '打孔机', '办公用品', 200, 100, '2009-02-23'),
                              ('002', '打孔机', '办公用品', 800, 100, '2009-02-23'),
                              ('002', '打孔机', '办公用品', 780, 100, '2009-02-23'),
                              ('002', '打孔机', '办公用品', null, 100, '2009-02-23');

insert into productIns (product_id, product_name, product_type,product_price)
                values ('006', '叉子', '厨房用具', 50)

-- 插入默认值
-- (但在创建表的时候： sale_price integer default 0)
-- 显式/隐式则忽略该列名以及赋值即可
default

/*
  清空表数据 (删除对象而不是表, 而是表中的数据行而不是列)
 */
delete from productIns where sale_price >= 25;


/*
  更新数据
 */
update product
    set sale_price = sale_price * 10,
        purchase_price = purchase / 2
where product_type = '厨房用具';


update product
    set (sale_price, purchase_price) = (sale_price * 10, purchase_price / 2)
where product_type = '厨房用具';


/*
  事务
  1.每条SQL语句就是一个事务
  2.直到用户执行COMMIT或者ROLLBACK为止算作一个事务
 */

--  MySQL (SQL server: begin || Oracle、DB2: 无)
start transaction; -- 开启事务
    -- DML语句
    update product
        set sale_price = sale_price + 200
    where product_type = 'T恤衣';

    -- DML语句
    update product
        set (sale_price, purchase_price) = (sale_price * 10, purchase_price / 2)
    where product_name = '厨房用具';

commit; -- 事务结束语句(或者rollback;)


/*
  视图
  优点：1)使用视图,不会将数据保存在任何地方(存储设备等),实际上保存的是select语句(节省存储设备的容量)
       2)将频繁使用select语句保存成视图,这样不用每次都重新书写.只需要在SELECT语句进行调用->得到结果
         随着原数据表变化->视图也会自动更新

  从视图读取数据：视图内部执行select语句并创建出一张临时表

  总结：视图读取数据->存储数据(不用创建实际的表存储数据,消耗存储空间)

  视图的限制：1)定义视图：不能使用order by子句-------(原因：视图和表一样,数据行是没有顺序的)
            2)更新视图：select语句未使用distinct、
                        from子句只有一张表、
                        未使用group by子句、
                        未使用having子句
 */

-- 创建视图
create view productSum (product_type, cnt_product)
as
select product_type, count(*)
    from product
    group by product_type;


-- 使用视图
select product_type, cnt_product
from productSum;

-- ps:可以在视图的基础上创建视图(多重视图)


-- 删除视图
drop view productSum;



/*
  子查询
  1)首先都是会先执行内部的select查询
 */
 select product_type, cnt_product
    -- 直接书写定义视图的select语句
    from (select product_type, count(*) as cnt_product
            from Product
                group by product_type) as ProductSum; -- 作为Product_type视图


/*
  where子句中不能使用标量子查询

  标量子查询：只能返回一行一列的数据

  应该如下：
 */
 select product_id, product_name, sale_price
    from Product
        where sale_price > (select AVG(sale_price)
                            from Product);

-- 若加入 group by product_type 即返回多组数据 -> 错误
-- 使用关联子查询：
-- 结合条件一定放在子查询中, 关联名称的作用域, 内部可以看到外部,外部不能看到内部
 select product_id, product_name, sale_price
    from Product as P1
        where sale_price > (select AVG(sale_price)
                                from Product as P2
                                    where P1.product_type = P2.prduct_type
                                        group by product_type);


